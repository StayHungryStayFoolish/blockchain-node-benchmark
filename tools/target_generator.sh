#!/bin/bash

# =====================================================================
# Universal Vegeta Test Target Generator - Multi-blockchain Support
# Supports address files generated by fetch_active_accounts.py
# =====================================================================

# Load configuration file
if ! source "$(dirname "${BASH_SOURCE[0]}")/../config/config_loader.sh" 2>/dev/null; then
    echo "‚ùå Error: Configuration file loading failed" >&2
    exit 1
fi

# Intelligent configuration check and repair
if [[ -z "${CURRENT_RPC_METHODS_STRING:-}" ]]; then
    echo "‚ö†Ô∏è Warning: CURRENT_RPC_METHODS_STRING not set, attempting to recalculate..." >&2
    CURRENT_RPC_METHODS_STRING="$(get_current_rpc_methods)"
    if [[ -z "$CURRENT_RPC_METHODS_STRING" ]]; then
        echo "‚ùå Error: Unable to get RPC method configuration" >&2
        echo "üí° Hint: Please check if BLOCKCHAIN_NODE and RPC_MODE environment variables are set correctly" >&2
        exit 1
    fi
    echo "‚úÖ Configuration recalculation completed: $CURRENT_RPC_METHODS_STRING" >&2
else
    echo "‚úÖ Configuration exists: $CURRENT_RPC_METHODS_STRING" >&2
    # When configuration exists, perform simple consistency check
    if [[ -n "$CHAIN_CONFIG" && "$CHAIN_CONFIG" != "null" ]]; then
        expected_method=$(echo "$CHAIN_CONFIG" | jq -r ".rpc_methods.\"$(echo "${RPC_MODE:-single}" | tr '[:upper:]' '[:lower:]')\"" 2>/dev/null)
        if [[ -n "$expected_method" && "$expected_method" != "null" && "$CURRENT_RPC_METHODS_STRING" != "$expected_method" ]]; then
            echo "üîß Configuration inconsistency, auto-repair: $expected_method" >&2
            CURRENT_RPC_METHODS_STRING="$expected_method"
        fi
    fi
fi

# Ensure RPC method array is initialized
if [[ -z "${CURRENT_RPC_METHODS_ARRAY:-}" ]]; then
    IFS=',' read -ra CURRENT_RPC_METHODS_ARRAY <<< "$CURRENT_RPC_METHODS_STRING"
fi

# Initialize variables (maintain backward compatibility)
VERBOSE=${VERBOSE:-false}

# Help information
show_help() {
    echo "Universal Vegeta Test Target Generator - Multi-blockchain Support"
    echo "Usage: $0 [options]"
    echo ""
    echo "Options:"
    echo "  -h, --help                 Show help information"
    echo "  -a, --accounts-file FILE   Input accounts file (default: ${ACCOUNTS_OUTPUT_FILE})"
    echo "  -o, --output FILE          Output target file (automatically selected based on mode)"
    echo "  --rpc-mode MODE            RPC mode: single, mixed (default: $RPC_MODE)"
    echo "  --rpc-url URL              RPC endpoint URL (default: $LOCAL_RPC_URL)"
    echo "  --output-single FILE       Single method target output file"
    echo "  --output-mixed FILE        Mixed method target output file"
    echo "  -v, --verbose              Enable verbose output"
    echo ""
    echo "Supported blockchains: solana, ethereum, bsc, base, polygon, scroll, starknet, sui"
    echo "Current blockchain: $BLOCKCHAIN_NODE"
    echo "RPC modes:"
    echo "  single: Generate targets using single RPC method"
    echo "  mixed: Generate targets using multiple RPC methods"
    echo ""
}

generate_rpc_json() {
    local method="$1"
    local address="$2"
    local rpc_url="$LOCAL_RPC_URL"

    # Get method parameter format (using JSON query function)
    local param_format
    param_format=$(get_param_format_from_json "$method")
    local params_json=""

    case "$param_format" in
        "no_params")
            params_json="[]"
            ;;
        "single_address")
            params_json="[\"$address\"]"
            ;;
        "address_latest")
            # EVM compatible chain format: ["address", "latest"]
            params_json="[\"$address\", \"latest\"]"
            ;;
        "latest_address")
            # StarkNet format: ["latest", "address"]
            params_json="[\"latest\", \"$address\"]"
            ;;
        "address_storage_latest")
            # eth_getStorageAt format: ["address", "0x0", "latest"]
            params_json="[\"$address\", \"0x0\", \"latest\"]"
            ;;
        "address_key_latest")
            # starknet_getStorageAt format: ["address", "0x1", "latest"]
            params_json="[\"$address\", \"0x1\", \"latest\"]"
            ;;
        "address_with_options")
            # sui_getObject format: ["address", options]
            params_json="[\"$address\", {\"showType\": true, \"showContent\": true, \"showDisplay\": false}]"
            ;;
        *)
            # Default to single address parameter
            echo "‚ö†Ô∏è Warning: Unknown parameter format $param_format for method $method, using default format" >&2
            params_json="[\"$address\"]"
            ;;
    esac

    # Generate JSON RPC request body
    local request_body="{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"$method\",\"params\":$params_json}"

    # Generate Vegeta target JSON
    jq -nc --arg method "POST" \
           --arg url "$rpc_url" \
           --arg body "$request_body" \
           '{
             method: $method,
             url: $url,
             header: {"Content-Type": ["application/json"]},
             body: ($body | @base64)
           }'
}

# Parameter parsing
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -a|--accounts-file)
                ACCOUNTS_OUTPUT_FILE="$2"
                shift 2
                ;;
            -o|--output)
                USER_OUTPUT_FILE="$2"
                shift 2
                ;;
            --rpc-mode)
                RPC_MODE="$2"
                echo "üîÑ RPC mode changed to: $RPC_MODE" >&2
                # When user actively changes RPC mode, directly recalculate
                if [[ -n "$CHAIN_CONFIG" && "$CHAIN_CONFIG" != "null" ]]; then
                    local rpc_mode_lower
                    rpc_mode_lower=$(echo "$RPC_MODE" | tr '[:upper:]' '[:lower:]')
                    CURRENT_RPC_METHODS_STRING=$(echo "$CHAIN_CONFIG" | jq -r ".rpc_methods.\"$rpc_mode_lower\"" 2>/dev/null)
                else
                    echo "‚ö†Ô∏è Warning: CHAIN_CONFIG unavailable, using fallback method" >&2
                    CURRENT_RPC_METHODS_STRING=$(get_current_rpc_methods)
                fi
                IFS=',' read -ra CURRENT_RPC_METHODS_ARRAY <<< "$CURRENT_RPC_METHODS_STRING"
                echo "‚úÖ RPC mode switch completed: $CURRENT_RPC_METHODS_STRING" >&2
                shift 2
                ;;
            --rpc-url)
                LOCAL_RPC_URL="$2"
                shift 2
                ;;
            --output-single)
                SINGLE_METHOD_TARGETS_FILE="$2"
                shift 2
                ;;
            --output-mixed)
                MIXED_METHOD_TARGETS_FILE="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            *)
                echo "Unknown option: $1" >&2
                shift
                ;;
        esac
    done

    # Set current output file based on RPC mode
    if [[ "$RPC_MODE" == "single" ]]; then
        CURRENT_OUTPUT_FILE="$SINGLE_METHOD_TARGETS_FILE"
    elif [[ "$RPC_MODE" == "mixed" ]]; then
        CURRENT_OUTPUT_FILE="$MIXED_METHOD_TARGETS_FILE"
    else
        echo "‚ùå Error: Invalid RPC mode: $RPC_MODE" >&2
        show_help
        return 1
    fi

    # If user specified output file via -o, override default setting
    if [[ -n "${USER_OUTPUT_FILE:-}" ]]; then
        CURRENT_OUTPUT_FILE="$USER_OUTPUT_FILE"
    fi
}

# Check dependencies
check_dependencies() {
    if ! command -v jq &> /dev/null; then
        echo "‚ùå Error: jq not installed" >&2
        return 1
    fi
}

# Check required configuration variables
check_required_variables() {
    local required_vars=(
        "ACCOUNTS_OUTPUT_FILE"
        "SINGLE_METHOD_TARGETS_FILE"
        "MIXED_METHOD_TARGETS_FILE"
        "LOCAL_RPC_URL"
        "BLOCKCHAIN_NODE"
        "CURRENT_RPC_METHODS_STRING"
    )

    local missing_vars=()
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            missing_vars+=("$var")
        fi
    done

    if [[ ${#missing_vars[@]} -gt 0 ]]; then
        echo "‚ùå Error: Required variables not set:" >&2
        for var in "${missing_vars[@]}"; do
            echo "  - $var" >&2
        done
        echo "Please ensure config_loader.sh is loaded correctly" >&2
        return 1
    fi

    return 0
}

# Check input file
check_input_file() {
    if [[ ! -f "$ACCOUNTS_OUTPUT_FILE" ]]; then
        echo "‚ùå Error: Accounts file does not exist: $ACCOUNTS_OUTPUT_FILE" >&2
        return 1
    fi

    # Check if file is empty
    if [[ ! -s "$ACCOUNTS_OUTPUT_FILE" ]]; then
        echo "‚ùå Error: Accounts file is empty: $ACCOUNTS_OUTPUT_FILE" >&2
        return 1
    fi
}

# Generate test targets - using configured method list
generate_targets() {
    echo "üéØ Generating Vegeta test targets..." >&2
    echo "   Blockchain type: $BLOCKCHAIN_NODE" >&2
    echo "   RPC mode: $RPC_MODE" >&2
    echo "   RPC methods: $CURRENT_RPC_METHODS_STRING" >&2
    echo "   Input file: $ACCOUNTS_OUTPUT_FILE" >&2
    echo "   Output file: $CURRENT_OUTPUT_FILE" >&2

    # Create output directory
    mkdir -p "$(dirname "$CURRENT_OUTPUT_FILE")"

    # Clear output file
    > "$CURRENT_OUTPUT_FILE"

    # Read account list
    local accounts=()
    while IFS= read -r address; do
        [[ -z "$address" ]] && continue
        accounts+=("$address")
    done < "$ACCOUNTS_OUTPUT_FILE"

    if [[ ${#accounts[@]} -eq 0 ]]; then
        echo "‚ùå Error: Accounts file is empty or contains no valid addresses" >&2
        return 1
    fi

    echo "‚úÖ Read ${#accounts[@]} accounts" >&2

    # Generate targets
    local count=0

    if [[ "$RPC_MODE" == "single" ]]; then
        # Single method mode
        local method="${CURRENT_RPC_METHODS_ARRAY[0]}"
        echo "üìù Using single method: $method" >&2

        for address in "${accounts[@]}"; do
            generate_rpc_json "$method" "$address" >> "$CURRENT_OUTPUT_FILE"
            ((count++))

            if [[ "$VERBOSE" == "true" && $((count % 100)) -eq 0 ]]; then
                echo "   Generated $count targets..." >&2
            fi
        done
    else
        # Mixed method mode
        local method_count=${#CURRENT_RPC_METHODS_ARRAY[@]}
        local account_index=0

        echo "üìù Using mixed methods: ${CURRENT_RPC_METHODS_ARRAY[*]}" >&2

        for address in "${accounts[@]}"; do
            local method_index=$((account_index % method_count))
            local method="${CURRENT_RPC_METHODS_ARRAY[$method_index]}"

            generate_rpc_json "$method" "$address" >> "$CURRENT_OUTPUT_FILE"

            ((count++))
            ((account_index++))

            if [[ "$VERBOSE" == "true" && $((count % 100)) -eq 0 ]]; then
                echo "   Generated $count targets (current method: $method)..." >&2
            fi
        done
    fi

    echo "‚úÖ Successfully generated $count test targets" >&2

    # Validate generated JSON
    if [[ "$VERBOSE" == "true" ]]; then
        echo "üîç Validating first target:" >&2
        head -n 1 "$CURRENT_OUTPUT_FILE" | jq '.' 2>/dev/null || echo "   JSON format validation failed" >&2

        echo "üîç Validating request body:" >&2
        head -n 1 "$CURRENT_OUTPUT_FILE" | jq -r '.body' 2>/dev/null | base64 -d 2>/dev/null | jq '.' 2>/dev/null || echo "   Request body decoding failed" >&2

        echo "üìä Total targets: $(wc -l < "$CURRENT_OUTPUT_FILE")" >&2
    fi
}

# Main function
main() {
    # Check dependencies
    if ! check_dependencies; then
        exit 1
    fi

    # Check required configuration variables
    if ! check_required_variables; then
        exit 1
    fi

    # Parse arguments
    parse_args "$@"

    # Final configuration validation and repair
    if [[ -z "${CURRENT_RPC_METHODS_STRING:-}" ]]; then
        echo "‚ùå Fatal error: RPC method configuration still empty after argument parsing" >&2
        echo "   BLOCKCHAIN_NODE: ${BLOCKCHAIN_NODE:-not set}" >&2
        echo "   RPC_MODE: ${RPC_MODE:-not set}" >&2

        if command -v get_current_rpc_methods >/dev/null 2>&1; then
            CURRENT_RPC_METHODS_STRING=$(get_current_rpc_methods)
            if [[ -n "$CURRENT_RPC_METHODS_STRING" ]]; then
                echo "‚úÖ Final repair successful: $CURRENT_RPC_METHODS_STRING" >&2
            else
                exit 1
            fi
        else
            exit 1
        fi
    fi
    
    # Ensure array is initialized
    if [[ -z "${CURRENT_RPC_METHODS_ARRAY:-}" ]]; then
        IFS=',' read -ra CURRENT_RPC_METHODS_ARRAY <<< "$CURRENT_RPC_METHODS_STRING"
    fi

    # Check input file
    if ! check_input_file; then
        exit 1
    fi

    # Generate test targets
    if ! generate_targets; then
        exit 1
    fi
}

# Execute main function
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi